diff --git a/android/build.gradle b/android/build.gradle
index 7df016db4507ab4a0c216622d15a9263b91f2cf2..dc94a38d57fd313e9bb40e0ef22f2e10034c57e6 100644
--- a/android/build.gradle
+++ b/android/build.gradle
@@ -1,5 +1,4 @@
 import java.nio.file.Paths
-import groovy.json.JsonSlurper
 
 buildscript {
   ext.getExtOrDefault = {name ->
@@ -27,57 +26,16 @@ def getExtOrIntegerDefault(name) {
   return rootProject.ext.has(name) ? rootProject.ext.get(name) : (project.properties["OPSQLite_" + name]).toInteger()
 }
 
-def useSQLCipher = false
+def useSQLCipher = true
 def useLibsql = false
 def useCRSQLite = false
-def performanceMode = false
+def performanceMode = true
 def sqliteFlags = ""
 def enableFTS5 = false
 def useSqliteVec = false
 def enableRtree = false
 def tokenizers = []
 
-// On the example app, the package.json is located at the root of the project
-// On the user app, the package.json is located at the root of the node_modules directory
-def isUserApp = rootDir.absolutePath.contains("node_modules")
-def packageJsonFile
-
-if (isUserApp) {
-  // Start from the root + 1 level up (to avoid detecting the op-sqlite/package.json) and traverse upwards to find the first package.json
-  File currentDir = new File("$rootDir/../")
-  packageJsonFile = null
-  
-  // Try to find package.json by traversing upwards
-  while (currentDir != null) {
-    File potential = new File(currentDir, "package.json")
-    if (potential.exists()) {
-      packageJsonFile = potential
-      break
-    }
-    currentDir = currentDir.parentFile
-  }
-} else {
-  packageJsonFile = new File("$rootDir/../package.json")
-}
-
-
-def packageJson = new JsonSlurper().parseText(packageJsonFile.text)
-
-def opsqliteConfig = packageJson["op-sqlite"]
-
-if(opsqliteConfig) {
-  println "[OP-SQLITE] Detected op-sqlite config from package.json at: " + packageJsonFile.absolutePath
-  useSQLCipher = opsqliteConfig["sqlcipher"]
-  useCRSQLite = opsqliteConfig["crsqlite"]
-  useSqliteVec = opsqliteConfig["sqliteVec"]
-  performanceMode = opsqliteConfig["performanceMode"]
-  sqliteFlags = opsqliteConfig["sqliteFlags"] ? opsqliteConfig["sqliteFlags"] : ""
-  enableFTS5 = opsqliteConfig["fts5"]
-  useLibsql = opsqliteConfig["libsql"]
-  enableRtree = opsqliteConfig["rtree"]
-  tokenizers = opsqliteConfig["tokenizers"] ? opsqliteConfig["tokenizers"] : []
-}
-
 if(useSQLCipher) {
   println "[OP-SQLITE] using sqlcipher."
 } else if(useLibsql) {
diff --git a/android/cpp-adapter.cpp b/android/cpp-adapter.cpp
index 5912d7b1ce5947d49418c34b60d7abbaf0810157..f2cb85bf3f01964669a216d6de06f5bb5d8846d2 100644
--- a/android/cpp-adapter.cpp
+++ b/android/cpp-adapter.cpp
@@ -19,8 +19,8 @@ struct OPSQLiteBridge : jni::JavaClass<OPSQLiteBridge> {
   static void registerNatives() {
     javaClassStatic()->registerNatives(
         {makeNativeMethod("installNativeJsi", OPSQLiteBridge::installNativeJsi),
-         makeNativeMethod("clearStateNativeJsi",
-                          OPSQLiteBridge::clearStateNativeJsi)});
+         makeNativeMethod("clearStateNativeJsi", OPSQLiteBridge::clearStateNativeJsi),
+    	    makeNativeMethod("deleteAllDBsJsi", OPSQLiteBridge::deleteAllDBsJsi)});
   }
 
 private:
@@ -39,6 +39,10 @@ private:
   static void clearStateNativeJsi(jni::alias_ref<jni::JObject> thiz) {
     opsqlite::invalidate();
   }
+
+  static bool deleteAllDBsJsi(jni::alias_ref<jni::JObject> thiz) {
+    return opsqlite::deleteAllDbs();
+  }
 };
 
 JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *) {
diff --git a/android/src/main/java/com/op/sqlite/OPSQLiteBridge.kt b/android/src/main/java/com/op/sqlite/OPSQLiteBridge.kt
index 44f86df6a21a6f7272b2c79b196586ef8fec886b..9d9f7100fd34361701b2addf09a4f36e33b35d56 100644
--- a/android/src/main/java/com/op/sqlite/OPSQLiteBridge.kt
+++ b/android/src/main/java/com/op/sqlite/OPSQLiteBridge.kt
@@ -12,6 +12,7 @@ class OPSQLiteBridge {
         docPath: String
     )
     private external fun clearStateNativeJsi()
+    private external fun deleteAllDBsJsi(): Boolean
 
     fun install(context: ReactContext) {
         val jsContextPointer = context.javaScriptContextHolder!!.get()
@@ -31,6 +32,10 @@ class OPSQLiteBridge {
         clearStateNativeJsi()
     }
 
+    fun deleteAllDBs() {
+        deleteAllDBsJsi()
+    }
+
     companion object {
         val instance = OPSQLiteBridge()
     }
diff --git a/android/src/main/java/com/op/sqlite/OPSQLiteModule.kt b/android/src/main/java/com/op/sqlite/OPSQLiteModule.kt
index 49a01b9f92641ed8c4ab91efe5fac4d42a0d4894..bdfa8294b3c876b563b9f7ea1efabd243ac5b12e 100644
--- a/android/src/main/java/com/op/sqlite/OPSQLiteModule.kt
+++ b/android/src/main/java/com/op/sqlite/OPSQLiteModule.kt
@@ -12,7 +12,7 @@ import java.io.InputStream
 import java.io.OutputStream
 import com.facebook.react.util.RNLog;
 
-internal class OPSQLiteModule(context: ReactApplicationContext?) : ReactContextBaseJavaModule(context) {
+class OPSQLiteModule(context: ReactApplicationContext?) : ReactContextBaseJavaModule(context) {
     override fun getName(): String {
         return NAME
     }
@@ -54,6 +54,16 @@ internal class OPSQLiteModule(context: ReactApplicationContext?) : ReactContextB
         throw Exception("Do not call getDylibPath on Android")
     }
 
+    @ReactMethod(isBlockingSynchronousMethod = true)
+    fun closeAllConnections() {
+        OPSQLiteBridge.instance.invalidate()
+    }
+
+    @ReactMethod(isBlockingSynchronousMethod = true)
+    fun deleteAllDBs() {
+        OPSQLiteBridge.instance.deleteAllDBs();
+    }
+
     @ReactMethod
     fun moveAssetsDatabase(args: ReadableMap, promise: Promise) {
         val filename = args.getString("filename")!!
diff --git a/cpp/DBHostObject.cpp b/cpp/DBHostObject.cpp
index eadea09354386b93831e22acfc7511b473b351d5..5701d158f3aa614c7aff9e99ad5ea68a271782b5 100644
--- a/cpp/DBHostObject.cpp
+++ b/cpp/DBHostObject.cpp
@@ -675,6 +675,10 @@ void DBHostObject::invalidate() {
 #endif
 }
 
+void DBHostObject::drop() {
+    opsqlite_remove(db, db_name, std::string(base_path));
+}
+
 DBHostObject::~DBHostObject() { invalidate(); }
 
 } // namespace opsqlite
diff --git a/cpp/DBHostObject.h b/cpp/DBHostObject.h
index 68a9bc496501307510db9c829886b0c73ac67a04..142e9d9b3398decd467b167f00350a63f46857f2 100644
--- a/cpp/DBHostObject.h
+++ b/cpp/DBHostObject.h
@@ -68,6 +68,7 @@ public:
   void on_commit();
   void on_rollback();
   void invalidate();
+  void drop();
   ~DBHostObject() override;
 
 private:
diff --git a/cpp/OPSqlite.cpp b/cpp/OPSqlite.cpp
index e33579af9527e8257b7c4fc38ef501a12fb848ce..791fa709faf35f60c9f9f3f1be43f814fef7dc45 100644
--- a/cpp/OPSqlite.cpp
+++ b/cpp/OPSqlite.cpp
@@ -42,6 +42,13 @@ void invalidate() {
   dbs.clear();
 }
 
+bool deleteAllDbs() {
+    for(const auto &db : dbs) {
+        db->drop();
+    }
+    return true;
+}
+
 void install(jsi::Runtime &rt,
              const std::shared_ptr<react::CallInvoker> &_invoker,
              const char *base_path, const char *crsqlite_path,
diff --git a/cpp/OPSqlite.hpp b/cpp/OPSqlite.hpp
index 91511ab8dff0cbd34c6b8b844c1783c39d4317cb..cc73dfe4405d568cbfbbfa5a9c879a1d88f260bf 100644
--- a/cpp/OPSqlite.hpp
+++ b/cpp/OPSqlite.hpp
@@ -14,6 +14,7 @@ void install(jsi::Runtime &rt,
              const char *base_path, const char *crsqlite_path,
              const char *sqlite_vec_path);
 void invalidate();
+bool deleteAllDbs();
 void expoUpdatesWorkaround(const char *base_path);
 
 } // namespace opsqlite
diff --git a/op-sqlite.podspec b/op-sqlite.podspec
index 32906a25cf057695d868bd0eaadb7b973b2aa8f7..4a1e452117fb7c61b33dd346aa120abfc691089e 100644
--- a/op-sqlite.podspec
+++ b/op-sqlite.podspec
@@ -1,12 +1,13 @@
-require "json"
 require_relative "./generate_tokenizers_header_file"
 
 log_message = lambda do |message|
   puts "\e[34m#{message}\e[0m"
 end
 
+# NOTE: Disabled as redundant for now, re-enable if needed
 # In the sample app the dir is not inside of node_modules
-is_user_app = __dir__.include?("node_modules")
+# is_user_app = __dir__.include?("node_modules")
+is_user_app = false
 package = JSON.parse(File.read(File.join(__dir__, "package.json")))
 app_package = nil
 package_json_path = nil
@@ -32,13 +33,13 @@ else
   package_json_path = File.join(__dir__, "example", "package.json")
 end
 
-app_package = JSON.parse(File.read(package_json_path))
+# NOTE: Disabled as redundant for now, re-enable if needed
+# app_package = JSON.parse(File.read(package_json_path))
 
-op_sqlite_config = app_package["op-sqlite"]
 use_sqlcipher = false
-use_crsqlite = false
+use_crsqlite = true
 use_libsql = false
-performance_mode = false
+performance_mode = true
 phone_version = false
 sqlite_flags = ""
 fts5 = false
@@ -46,37 +47,6 @@ rtree = false
 use_sqlite_vec = false
 tokenizers = []
 
-if(op_sqlite_config != nil)
-  use_sqlcipher = op_sqlite_config["sqlcipher"] == true
-  use_crsqlite = op_sqlite_config["crsqlite"] == true
-  use_libsql = op_sqlite_config["libsql"] == true
-  performance_mode = op_sqlite_config["performanceMode"] || false
-  phone_version = op_sqlite_config["iosSqlite"] == true
-  sqlite_flags = op_sqlite_config["sqliteFlags"] || ""
-  fts5 = op_sqlite_config["fts5"] == true
-  rtree = op_sqlite_config["rtree"] == true
-  use_sqlite_vec = op_sqlite_config["sqliteVec"] == true
-  tokenizers = op_sqlite_config["tokenizers"] || []
-end
-
-if phone_version then
-  if use_sqlcipher then
-    raise "SQLCipher is not supported with phone version. It cannot load extensions."
-  end
-
-  if use_crsqlite then
-    raise "CRSQLite is not supported with phone version. It cannot load extensions."
-  end
-
-  if rtree then
-    raise "RTree is not supported with phone version. It cannot load extensions."
-  end
-
-  if use_sqlite_vec then
-    raise "SQLite Vec is not supported with phone version. It cannot load extensions."
-  end
-end
-
 Pod::Spec.new do |s|
   s.name         = "op-sqlite"
   s.version      = package["version"]
